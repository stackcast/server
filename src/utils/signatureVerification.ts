import { verifyMessageSignatureRsv } from "@stacks/encryption";
import { serializeCVBytes, standardPrincipalCV, uintCV, bufferCV } from "@stacks/transactions";
import { createHash } from "crypto";

/**
 * Compute order hash matching ctf-exchange.clar's hash-order function
 *
 * This hash is what users sign with their Stacks wallet to authorize trades.
 * The hash MUST match exactly between frontend, backend, and smart contract.
 *
 * Flow:
 * 1. Frontend: User signs this hash → gets 65-byte ECDSA signature
 * 2. Backend: Verifies signature recovers to maker's public key
 * 3. Smart contract: Verifies same hash + signature on-chain during settlement
 *
 * Hash algorithm (matches ctf-exchange.clar:46-78):
 * sha256(
 *   consensus(maker) + consensus(taker) +
 *   makerPositionId + takerPositionId +
 *   consensus(makerAmount) + consensus(takerAmount) +
 *   consensus(salt) + consensus(expiration)
 * )
 *
 * Example: BUY 100 YES @ 66¢
 *   maker: SP2ABC...
 *   taker: SP2ABC... (same as maker for limit orders)
 *   makerPositionId: 0xabc123... (NO tokens - what user gives)
 *   takerPositionId: 0xdef456... (YES tokens - what user gets)
 *   makerAmount: 100 (YES tokens user wants)
 *   takerAmount: 6600 (cost in cents: 100 * 66)
 *   salt: "1234567890" (random nonce)
 *   expiration: 999999 (Stacks block height)
 */
export function computeOrderHash(
  maker: string,
  taker: string,
  makerPositionId: string,
  takerPositionId: string,
  makerAmount: number,
  takerAmount: number,
  salt: string,
  expiration: number
): Buffer {
  // Validate salt is numeric (required for Clarity uint conversion)
  if (!/^\d+$/.test(salt)) {
    throw new Error("Salt must be a numeric string");
  }

  // Serialize principals to Clarity consensus format
  // standardPrincipalCV converts "SP2ABC..." → Clarity principal type
  // Using serializeCVBytes which returns Uint8Array directly
  const makerBuff = Buffer.from(serializeCVBytes(standardPrincipalCV(maker)));
  const takerBuff = Buffer.from(serializeCVBytes(standardPrincipalCV(taker)));

  // Position IDs are raw 32-byte buffers (generated by conditional-tokens.clar)
  // Example: sha256(conditionId + outcomeIndex) → 32 bytes
  const makerPositionIdBuff = Buffer.from(makerPositionId, "hex");
  const takerPositionIdBuff = Buffer.from(takerPositionId, "hex");

  // Validate position ID lengths (contract expects exactly 32 bytes)
  if (makerPositionIdBuff.length !== 32) {
    throw new Error(`Maker position ID must be 32 bytes (64 hex chars), got ${makerPositionIdBuff.length} bytes`);
  }
  if (takerPositionIdBuff.length !== 32) {
    throw new Error(`Taker position ID must be 32 bytes (64 hex chars), got ${takerPositionIdBuff.length} bytes`);
  }

  // Serialize amounts to Clarity uint format
  // uintCV() accepts number/string/bigint and handles conversion internally
  // Using serializeCVBytes which returns Uint8Array directly
  const makerAmountBuff = Buffer.from(serializeCVBytes(uintCV(makerAmount)));
  const takerAmountBuff = Buffer.from(serializeCVBytes(uintCV(takerAmount)));
  const saltBuff = Buffer.from(serializeCVBytes(uintCV(salt)));
  const expirationBuff = Buffer.from(serializeCVBytes(uintCV(expiration)));

  // Concatenate in EXACT order as ctf-exchange.clar (line 56-77)
  // Order matters! Even one byte out of place breaks signature verification
  const concatenated = Buffer.concat([
    makerBuff,
    takerBuff,
    makerPositionIdBuff,
    takerPositionIdBuff,
    makerAmountBuff,
    takerAmountBuff,
    saltBuff,
    expirationBuff,
  ]);

  // Hash with raw SHA-256 (NOT Stacks hashMessage which adds "\x18Stacks Signed Message:" prefix)
  const hash = createHash("sha256").update(concatenated).digest();

  return hash;
}

/**
 * Verify ECDSA secp256k1 signature from Stacks wallet
 *
 * Validates that the signature was created by the maker's private key.
 * Uses public key recovery to verify authenticity without needing the private key.
 *
 * @param orderHash - 32-byte hash user signed (output of computeOrderHash)
 * @param signature - RSV format signature (65 bytes = 130 hex chars)
 *   - R: 32 bytes (x-coordinate of ephemeral public key)
 *   - S: 32 bytes (signature proof)
 *   - V: 1 byte (recovery ID, 0-3)
 * @param publicKey - Compressed public key from Stacks wallet (33 bytes)
 * @returns true if signature is valid and matches publicKey
 *
 * Security: This prevents order forgery. Only the wallet owner can sign valid orders.
 */
export function verifyOrderSignature(
  orderHash: Buffer,
  signature: string,
  publicKey: string
): boolean {
  try {
    // Validate signature length (65 bytes in hex = 130 chars)
    if (signature.length !== 130) {
      console.error(
        `Invalid signature length: ${signature.length}, expected 130`
      );
      return false;
    }

    // Verify using Stacks' ECDSA verification (secp256k1 curve)
    // This recovers the public key from (hash, signature) and checks it matches
    const verified = verifyMessageSignatureRsv({
      message: orderHash.toString("hex"),
      signature,
      publicKey, // Compressed public key from wallet (starts with 02/03)
    });

    return verified;
  } catch (error) {
    console.error("Signature verification error:", error);
    return false;
  }
}

/**
 * Verify order signature middleware - validates signed orders before acceptance
 *
 * Why we verify signatures:
 * - Prevents unauthorized order placement (only wallet owner can sign)
 * - Ensures order parameters haven't been tampered with
 * - Provides same security as on-chain settlement (signatures verified again by contract)
 *
 * Flow:
 * 1. Compute order hash from parameters (must match what user signed)
 * 2. Verify signature recovers to maker's public key
 * 3. Return validation result
 *
 * Note: For LIMIT orders, taker = maker (user is willing to trade with anyone)
 */
export async function verifyOrderSignatureMiddleware(orderData: {
  maker: string;
  taker?: string;
  makerPositionId: string;
  takerPositionId: string;
  makerAmount: number;
  takerAmount: number;
  salt: string;
  expiration: number;
  signature: string;
  publicKey: string;
}): Promise<{ valid: boolean; error?: string }> {
  const {
    maker,
    taker,
    makerPositionId,
    takerPositionId,
    makerAmount,
    takerAmount,
    salt,
    expiration,
    signature,
    publicKey,
  } = orderData;

  // Validate required fields
  if (!signature) {
    return { valid: false, error: "Signature is required" };
  }

  if (!publicKey) {
    return { valid: false, error: "Public key is required" };
  }

  if (!maker) {
    return { valid: false, error: "Maker address is required" };
  }

  if (!makerPositionId) {
    return { valid: false, error: "Maker position ID is required" };
  }

  if (!takerPositionId) {
    return { valid: false, error: "Taker position ID is required" };
  }

  // For limit orders: maker willing to trade with anyone (taker = maker)
  // For market orders: specific taker matched by engine
  const takerAddress = taker || maker;

  try {
    // Compute the order hash (must match what user signed in frontend)
    const orderHash = computeOrderHash(
      maker,
      takerAddress,
      makerPositionId,
      takerPositionId,
      makerAmount,
      takerAmount,
      salt,
      expiration
    );

    // Verify the signature was created by maker's wallet
    const isValid = verifyOrderSignature(orderHash, signature, publicKey);

    if (!isValid) {
      return { valid: false, error: "Invalid signature" };
    }

    return { valid: true };
  } catch (error: any) {
    console.error("Order signature verification failed:", error);
    return {
      valid: false,
      error: error.message || "Signature verification failed",
    };
  }
}
